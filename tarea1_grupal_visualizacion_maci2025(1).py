# -*- coding: utf-8 -*-
"""tarea1_grupal_visualizacion_maci2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZ6LIfcW6SLxAP506pkP-DQU6Q9BzSJd

# Proyecto Dashboard


  El proyecto consiste en desarrollar un Dashboard, que integre un conjunto de visualizaciones
significativo en el dominio o ámbito de un dataset a elegir. El proyecto será desarrollado en equipos
de 3 integrantes.

Los aspectos a evaluar serán los siguientes:

Objetivo de la visualización (15 puntos): debe estar explícitamente incluido en la visualización.

Todos los componentes de la visualización deberán contribuir a dicho objetivo, lo que puede ser
reforzado con texto explicativo. El objetivo incluirá una descripción de potenciales usuarios y
contexto de uso.

Pertinencia y corrección del Dashboard (40 puntos): el Dashboard y sus componentes, junto
con estar correctamente implementados, deberán responder al objetivo específico que se
anuncia (ej: a continuación, mostramos la evolución en el tiempo de esta variable => lineplot, o
vemos cómo se corresponde esta variable con esta otra => scatter o bubbleplot). Mínimo 5
gráficos, máximo 8 (*)

Uso de color y texto (15 puntos): en cada gráfica o visualización componente, el uso de títulos,
etiquetas, textos descriptivos y colores, debe ser concordante con los objetivos descritos.

Organización y coherencia (10 puntos): las visualizaciones deben organizarse
significativamente en la pantalla, y ser coherentes o complementarias entre sí. El usuario debe
entender cada una de las visualizaciones y su orden de presentación.

Presentación y demostración (20 puntos): el diseño y ejecución del dashboard debe ser
presentado. Se evaluarán los aspectos anteriores en una exposición de no más de 15 minutos,
más las respuestas y participación en un periodo de consultas y discusión de 10 minutos.

Escala de notas: http://bit.ly/3ypiNep (http://bit.ly/3ypiNep)

(*) Los gráficos elegidos deben corresponder, cada uno, a una de las siguientes categorías:

a) gráficas de series de tiempo

b) gráficas comparativas de dos variables en el tiempo

c) gráficas de distribución estadística

d) gráficas de composición

e) gráficas de correlación

f) nube de palabras clave

g) mapas con marcadores o coropléticos, de acuerdo al nivel de granularidad de los mapas

Entrega:

Los entregables consisten en:

Código fuente, con comentarios que contribuyan a su comprensión, análisis y pruebas (ej:
indicación de parámetros modificables), en sistema gestor de versiones Github o similar
Demostración de su ejecución (deseable respaldarse con vídeo de ejecución).
Algunos datasets que pueden utilizar (pueden usar propios)
COVID19 (minciencia.gob.cl)

Elegir datasets de acuerdo a objetivo consensuado por equipo :

(https://www.minciencia.gob.cl/covid19/)
SOWC-Statistical-tables-ALL-2021-ES.xlsx

(https://udec.instructure.com/courses/67338/files/3739117?wrap=1)
(https://udec.instructure.com/courses/67338/files/3739117/download?download_frd=1)
(Múltiples datos de UNICEF, pueden repartirse entre grupos las distintas hojas del libro)

https://grouplens.org/datasets/movielens/ (https://grouplens.org/datasets/movielens/)
(Dataset de películas y puntuaciones de usuarios)

Datasets de Kaggle (https://www.kaggle.com/datasets)

Datasets de PapersWithCode (https://paperswithcode.com/datasets)

datos : datos
Fecha

Condición (clima, luz)

Tipo de choque

Condición de la calle

Daño en $$
Causa del choque



Cliente:

municipalidad

Objetivo general

Analizar información de datos para poder realizar campaña de prevención de accidentes de autos

Objetivos específicos

Analizar la gravedad del siniestro

Revisar fechas para poder generar campañas

Análisis de condiciones: climáticas, iluminación, momento del día, calle

Tipo de accidente

Costo del accidente

Fuete de datos : https://www.kaggle.com/datasets/oktayrdeki/traffic-accidents

Exploracion de datos

PROYECTO PROPAGANDA DE PREVENCIÓN DE ACCIDENTES
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from IPython.display import display, HTML
csv_datos= '/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/traffic_accidents.csv'
df_datos= pd.read_csv(csv_datos)
#df_datos= pd.read_csv(csv_datos, sep=';')
# Título del DataFrame con formato
titulo = "<h2 style='font-size: 24px; font-weight: bold;'>LIMPIEZA DE DATOS</h2>"

# Mostrar el título
display(HTML(titulo))

# Mostrar el DataFrame
display(df_datos.head(5))

titulo_desc = "<h2 style='font-size: 24px; font-weight: bold;'>DESCRIPCIÓN DE LOS DATOS</h2>"

# Mostrar el título
display(HTML(titulo_desc))
df_datos.describe()

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>TIPO DE DATOS</h2>"

# Mostrar el título
display(HTML(titulo_type))
# datos
print(df_datos.dtypes)

import pandas as pd

# Mostrar los valores únicos de la columna
traffic_control_device = df_datos['weather_condition'].unique()

# Mostrar los valores
print(traffic_control_device)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


# Graficar la frecuencia de los valores de la columna
plt.figure(figsize=(10, 6))

# Crear el gráfico de barras (conteo de categorías)
sns.countplot(data=df_datos, x='weather_condition', palette='Set2')

# Añadir títulos y etiquetas
plt.title('Frecuencia')#, fontsize=14)
plt.xlabel('Clima') , #fontsize=8)
plt.ylabel('Frecuencia') #, fontsize=12)

plt.xticks(fontsize=10, rotation=45)
plt.yticks(fontsize=10)

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 1: REVISAR LA CONDICIÓN CLIMÁTICA QUE MÁS INCIDE EN EL ACCIDENTE</h2>"

# Mostrar el título
display(HTML(titulo_type))

# Mostrar el gráfico
plt.show()

"""

```
# Tiene formato de código
```

#PARTE VICKY
  ![image.png](data:image/png;base64,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)"""

import matplotlib.pyplot as plt
import seaborn as sns

# Estilo de gráficos
sns.set(style="whitegrid")

# Gráfico de distribución por hora del día
plt.figure(figsize=(10, 6))
sns.histplot(df_datos['crash_hour'].dropna(), bins=24, kde=False)
plt.title('Distribución de Accidentes por Hora del Día')
plt.xlabel('Hora del Día (0-23)')
plt.ylabel('Cantidad de Accidentes')
plt.xticks(range(0, 24))  # Marcar todas las horas

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 2: ANALIZAR EL HORARIO DEL ACCIDENTE</h2>"

# Mostrar el título
display(HTML(titulo_type))
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


# Contar ocurrencias por condición climática
weather_counts = df_datos['lighting_condition'].value_counts()

# Agrupar categorías menores bajo "OTROS"
threshold = 0.03  # Agrupar si es menos del 3% del total
total = weather_counts.sum()
weather_grouped = weather_counts[weather_counts / total >= threshold]
otros = weather_counts[weather_counts / total < threshold].sum()
weather_grouped["OTROS"] = otros

# Preparar datos
labels = weather_grouped.index
sizes = weather_grouped.values
explode = [0.05 if size / sum(sizes) < 0.1 else 0 for size in sizes]  # resaltar los más pequeños

# Crear gráfico de pastel
plt.figure(figsize=(12, 10))
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    startangle=140,
    explode=explode,
    pctdistance=0.8,
    labeldistance=1.1,
    textprops={'fontsize': 11},
    wedgeprops=dict(edgecolor='white'),
    radius=0.8
)

# Añadir flechas a cada segmento, desde la orilla hacia las etiquetas
for i, wedge in enumerate(wedges):
    angle = (wedge.theta2 + wedge.theta1) / 2  # Ángulo medio del segmento
    x = wedge.r * np.cos(np.radians(angle))  # Coordenada x en la orilla
    y = wedge.r * np.sin(np.radians(angle))  # Coordenada y en la orilla
    # Coordenadas donde apunta la flecha (hacia las etiquetas)
    label_x, label_y = texts[i].get_position()

    plt.annotate(
        '',
        xy=(label_x, label_y),  # Coordenada donde apunta la flecha (la etiqueta)
        xytext=(x, y),  # Coordenada desde donde sale la flecha (la orilla de la torta)
        arrowprops=dict(arrowstyle='->', lw=1.5, color='gray')  # Estilo de la flecha gris
    )


titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 3: ANALIZAR COMO INFLUYE LA LUZ DEL DÍA</h2>"

# Mostrar el título
display(HTML(titulo_type))

# Título
plt.title('Composición de Accidentes por Condición Climática (Agrupado)', fontsize=14)

# Mostrar gráfico
plt.tight_layout()
plt.show()

"""first_crash_type_PEDESTRIAN → correlación: 0.15

🔺 Cuando el primer impacto es con un peatón, hay más probabilidad de que haya personas lesionadas.

✔️ Tiene sentido, ya que los peatones son más vulnerables.

damage_OVER $1,500 → correlación: 0.12

🔺 Accidentes con alto daño económico tienden a tener más heridos.

Puede ser reflejo de accidentes más violentos.

PARTE FABI
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Paso 1: unir todos los valores de la columna en un solo string
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))

# Paso 2: crear el WordCloud
wordcloud = WordCloud(width=800, height=400, background_color='white', collocations=False).generate(text)

# Paso 3: mostrar el WordCloud
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 4: COMPRENDER QUE HACÍA EL VEHICULO CUANDO OCURRE EL CHOQUE</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.figure(figsize=(10, 5))
plt.title('Gráfico de palabras de Tipo de choque', fontsize=18)
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

"""Parte Gabriel

b) Gráficas comparativas de dos variables en el tiempo

     - lineplot
     Típicamente, el eje-y representa un valor cuantitativo , mientras el x es una esacala de tiempos

     - area plot
     Puede ser usada para mostrar comparativamente la evolucion de variables en el tiempo

    -Similar a un Lineplot, es otra representación de la evolución de una variable numérica
    • El área entre la línea trazada por la unión de los data points y el eje-x es llenada con color o sombra
    • Se discute su alta relación Tinta/Dato
    • Puede ser difícil de visualizar cantidades en áreas apiladas
    • Puede ser difícil distinguirvarias variables en áreas no apiladas

    BAR CHARTS                                                                  • Compara datos cuantitativos de diferentes ítems o categorías           -   Describe cambios en el tiempo, para periodo significativos y discretos



"""

import pandas as pd


# Crear un nuevo DataFrame df_datos_II que solo contenga tres columnas especificadas
df_datos_II = df_datos[['crash_date', 'injuries_incapacitating', 'injuries_non_incapacitating','crash_month']]

# Mostrar las primeras filas
print(df_datos_II.head())

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Crear un nuevo DataFrame df_datos_II que solo contenga las tres columnas especificadas
df_datos_III = df_datos[['crash_month', 'injuries_incapacitating', 'injuries_non_incapacitating']]

# Agrupar por 'crash_month' y contar la cantidad de accidentes incapacitating y no incapacitating
df_injuries = df_datos_III.groupby(['crash_month'])[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()

# Graficar en un gráfico de área comparativa
df_injuries.plot(kind='area',
                 alpha=0.5,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                 stacked=False,
                 figsize=(12, 6),
                 color=['red', 'blue'])  # Cambiar colores: rojo para incapacitantes y azul para no incapacitantes)

plt.title('Comparativa de Accidentes Incapacitantes y No Incapacitantes agrupados por meses (2013 -2024)')
plt.ylabel('Número de Accidentes')
plt.xlabel('Meses')
plt.xticks(rotation=45)  # Para rotar las etiquetas de fecha
plt.tight_layout()  # Ajustar el diseño para que no se solapen los elementos
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 5: ANALIZAR SI EXISTE UNA VARIACIÓN SEGÚN EL MES DEL AÑO, DE ACCIDENTE INCAPACITANTES Y NO INCAPACITANTES</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.show()

"""e) Gráficas de correlación

SCATTER PLOT • Despliega valores de dos variables, una en cada eje cartesiano.

• Permite detectar si existe una relación o correlación entre ambas variables.

SCATTER PLOT: TIPOS DE CORRELACIÓN

• Positiva: x e y aumentan juntos

• Negativa: uno aumenta y el otro disminuye

• Nula: no hay correlación

• Lineal

• Exponencial

• Forma de U

SCATTER PLOT: FORTALEZA DE CORRELACIÓN

• La fortaleza de la correlación se determina por la cercanía entre los puntos en el gráfico.

• Puntos muy fuera de los cluster de puntos son outliers.

SCATTER PLOT: DESCRIPCIÓN

Los markers representan la correspondencia entre dos valores de correspondientes variables descritas en los ejes x e Y.

• Se muestra una línea que representa la función de regresión lineal más descriptiva de la correspondencia entre las variables • Opcionalmente, se muestra el intervalo de confianza asociado

¿ Bubble Chart ?
"""

# SCATTER PLOT : graficos de correlacion
# instalación de seaborn
!conda install -c anaconda seaborn --yes

# importamos biblioteca
import seaborn as sns

print('Seaborn installed and imported!')

#crea un nuevo df

# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year

# Agrupar por año y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Mostrar el DataFrame resultante
print(df_datos_scatter.head())

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year



# Agrupar por 'year' y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float (útil para posterior regresión)
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Crear un scatter plot con seaborn
sns.set_style("dark")
ax = sns.regplot(x='year', y='total_accidents', data=df_datos_scatter, marker="o")

plt.title(' Accidentes Totales por Año')
plt.xlabel('Año')
plt.ylabel('Accidentes Totales')
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 6: ANALIZAR SI EXISTE UNA VARIACIÓN EN EL TIEMPO DEL TOTAL DE ACCIDENTES</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.show()

"""Bubble Charts

"""

import pandas as pd


# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year


# Agrupar por año y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Agrupar por año y sumar el número total de unidades
df_units = pd.DataFrame(df_datos.groupby('year')['num_units'].sum())

# Resetear el índice para regresarlo como columna en el DataFrame df_units
df_units.reset_index(inplace=True)

# Renombrar columnas
df_units.columns = ['year', 'total_units']

# Combinar los DataFrames df_totals y df_units
df_datos_b = pd.merge(df_totals, df_units, on='year')

# Mostrar el DataFrame resultante
print(df_datos_b.head(11))

"""Animación del bubblechart  en el tiempo, considerando todos los años del dataset

Instalando librerias
"""

# instalamos plotly
!conda install -c anaconda plotly --yes
# instalamos plotly express, para resultados con mayor interactividad
!conda install -c plotly plotly_express --yes
# instalamos plotly express, para resultados con mayor interactividad
!conda install -c plotly plotly_express --yes
# instalamos plotly
!pip install plotly

!pip install plotly
import plotly.express as px

!pip install dash
!pip install pyngrok
!pip install dash dash-bootstrap-components plotly pandas wordcloud
!pip install dash dash-bootstrap-components pyngrok wordcloud

import dash
from dash import dcc, html, Input, Output
import plotly.express as px
import pandas as pd
from wordcloud import WordCloud
from io import BytesIO
import base64
from pyngrok import ngrok
import threading

# ✅ Simulación del DataFrame (puedes reemplazar por el tuyo)
# df_datos = pd.read_csv("tu_archivo.csv")
df_datos = pd.DataFrame({
    'weather_condition': ['Clear', 'Rain', 'Snow'] * 100,
    'crash_hour': [i % 24 for i in range(300)],
    'lighting_condition': ['Daylight', 'Darkness', 'Dawn'] * 100,
    'first_crash_type': ['Turning', 'Rear-end', 'Sideswipe'] * 100,
    'crash_month': ['Enero', 'Febrero', 'Marzo'] * 100,
    'injuries_incapacitating': [i % 5 for i in range(300)],
    'injuries_non_incapacitating': [i % 7 for i in range(300)],
    'crash_date': ['01/01/2023 01:00:00 AM'] * 300,
    'injuries_total': [i % 10 for i in range(300)]
})

# Preparar datos para gráficos
df_datos['crash_date'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p")
df_datos['year'] = df_datos['crash_date'].dt.year

# Crear WordCloud
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))
wordcloud = WordCloud(width=800, height=400, background_color='white').generate(text)
img = BytesIO()
wordcloud.to_image().save(img, format='PNG')
img_base64 = base64.b64encode(img.getvalue()).decode()

# Crear la app
app = dash.Dash(__name__)
server = app.server

app.layout = html.Div([
    html.H1("Dashboard de Accidentes de Tráfico", style={'textAlign': 'center'}),

    html.Div([
        html.Div([
            html.H3("OBJETIVO 1: Condición climática más incidente"),
            dcc.Graph(
                figure=px.histogram(df_datos, x='weather_condition')
            )
        ], className='six columns'),

        html.Div([
            html.H3("OBJETIVO 2: Análisis de horario"),
            dcc.Graph(
                figure=px.histogram(df_datos, x='crash_hour', nbins=24)
            )
        ], className='six columns'),
    ], className='row'),

    html.Div([
        html.Div([
            html.H3("OBJETIVO 3: Iluminación al momento del accidente"),
            dcc.Graph(
                figure=px.pie(
                    names=(df_datos['lighting_condition'].value_counts().index),
                    values=(df_datos['lighting_condition'].value_counts().values)
                )
            )
        ], className='six columns'),

        html.Div([
            html.H3("OBJETIVO 4: WordCloud del tipo de choque"),
            html.Img(src=f'data:image/png;base64,{img_base64}', style={"width": "100%"})
        ], className='six columns'),
    ], className='row'),

    html.Div([
        html.H3("OBJETIVO 5: Accidentes mensuales"),
        dcc.Graph(
            figure=px.area(
                df_datos.groupby('crash_month')[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()
            )
        )
    ]),

    html.Div([
        html.H3("OBJETIVO 6: Evolución anual de accidentes"),
        dcc.Graph(
            figure=px.scatter(
                df_datos.groupby('year')['injuries_total'].sum().reset_index(),
                x='year', y='injuries_total', trendline='ols'
            )
        )
    ])
])

def run_dash():
    app.run(port=8050)

# Crear túnel ngrok
public_url = ngrok.connect(8050)
print("Tu dashboard interactivo está en:", public_url)

# Iniciar el servidor Dash en segundo plano
thread = threading.Thread(target=run_dash)
thread.start()

'''import pandas as pd
import plotly.express as px
from wordcloud import WordCloud
from io import BytesIO
import base64

# Asegúrate de tener cargado df_datos

# Gráfico 1
fig1 = px.histogram(df_datos, x='weather_condition')
fig1.update_layout(title=None)
html1 = fig1.to_html(full_html=False, include_plotlyjs='cdn', config={'displayModeBar': False})

# Gráfico 2
fig2 = px.histogram(df_datos, x='crash_hour', nbins=24)
fig2.update_layout(title=None)
html2 = fig2.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# Gráfico 3
lighting = df_datos['lighting_condition'].value_counts()
grouped = lighting[lighting / lighting.sum() >= 0.03]
grouped['OTROS'] = lighting[lighting / lighting.sum() < 0.03].sum()
fig3 = px.pie(names=grouped.index, values=grouped.values)
fig3.update_layout(title=None)
html3 = fig3.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# WordCloud (Gráfico 4)
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))
wordcloud = WordCloud(width=800, height=400, background_color='white').generate(text)
img = BytesIO()
wordcloud.to_image().save(img, format='PNG')
img_base64 = base64.b64encode(img.getvalue()).decode()

# Gráfico 5
df_datos_mes = df_datos.groupby('crash_month')[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()
fig5 = px.area(df_datos_mes)
fig5.update_layout(title=None)
html5 = fig5.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# Gráfico 6
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year
df_datos_anual = df_datos.groupby('year')['injuries_total'].sum().reset_index()
fig6 = px.scatter(df_datos_anual, x='year', y='injuries_total', trendline="ols")
fig6.update_layout(title=None)
html6 = fig6.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# HTML final con layout 2, 2, 1, 1
html_dashboard = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dashboard de Accidentes</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {{
            font-family: 'Segoe UI', sans-serif;
            background-color: #f4f6f8;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1200px;
            margin: auto;
        }}
        h1 {{
            text-align: center;
            color: #333;
            margin-bottom: 40px;
        }}
        .grid {{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }}
        .card {{
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            padding: 20px;
        }}
        .card h2 {{
            font-size: 18px;
            color: #007BFF;
            margin-bottom: 10px;
        }}
        .full-width {{
            grid-column: span 2;
        }}
        img {{
            width: 100%;
            max-width: 800px;
            display: block;
            margin: auto;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
        }}
        @media (max-width: 768px) {{
            .grid {{
                grid-template-columns: 1fr;
            }}
            .full-width {{
                grid-column: span 1;
            }}
        }}
    </style>
</head>
<body>

<div class="container">
    <h1>Dashboard de Accidentes de Tráfico</h1>

    <div class="grid">
        <div class="card">
            <h2>OBJETIVO 1: REVISAR LA CONDICIÓN CLIMÁTICA QUE MÁS INCIDE EN EL ACCIDENTE</h2>
            {html1}
        </div>
        <div class="card">
            <h2>OBJETIVO 2: ANALIZAR EL HORARIO DEL ACCIDENTE</h2>
            {html2}
        </div>

        <div class="card">
            <h2>OBJETIVO 3: ANALIZAR CÓMO INFLUYE LA LUZ DEL DÍA</h2>
            {html3}
        </div>
        <div class="card">
            <h2>OBJETIVO 4: COMPRENDER QUÉ HACÍA EL VEHÍCULO CUANDO OCURRE EL CHOQUE</h2>
            <img src="data:image/png;base64,{img_base64}" alt="WordCloud del tipo de choque">
        </div>

        <div class="card full-width">
            <h2>OBJETIVO 5: ANALIZAR LA VARIACIÓN MENSUAL DE ACCIDENTES INCAPACITANTES Y NO INCAPACITANTES</h2>
            {html5}
        </div>
        <div class="card full-width">
            <h2>OBJETIVO 6: ANALIZAR LA EVOLUCIÓN EN EL TIEMPO DEL TOTAL DE ACCIDENTES</h2>
            {html6}
        </div>
    </div>
</div>

</body>
</html>
"""

# Guardar archivo
with open("dashboard_accidentes.html", "w", encoding="utf-8") as f:
    f.write(html_dashboard)

# Descargar desde Colab
from google.colab import files
files.download("dashboard_accidentes.html")