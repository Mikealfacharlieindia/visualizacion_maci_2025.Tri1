# -*- coding: utf-8 -*-
"""tarea1_grupal_visualizacion_maci2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZ6LIfcW6SLxAP506pkP-DQU6Q9BzSJd

# Proyecto Dashboard


  El proyecto consiste en desarrollar un Dashboard, que integre un conjunto de visualizaciones
significativo en el dominio o √°mbito de un dataset a elegir. El proyecto ser√° desarrollado en equipos
de 3 integrantes.

Los aspectos a evaluar ser√°n los siguientes:

Objetivo de la visualizaci√≥n (15 puntos): debe estar expl√≠citamente incluido en la visualizaci√≥n.

Todos los componentes de la visualizaci√≥n deber√°n contribuir a dicho objetivo, lo que puede ser
reforzado con texto explicativo. El objetivo incluir√° una descripci√≥n de potenciales usuarios y
contexto de uso.

Pertinencia y correcci√≥n del Dashboard (40 puntos): el Dashboard y sus componentes, junto
con estar correctamente implementados, deber√°n responder al objetivo espec√≠fico que se
anuncia (ej: a continuaci√≥n, mostramos la evoluci√≥n en el tiempo de esta variable => lineplot, o
vemos c√≥mo se corresponde esta variable con esta otra => scatter o bubbleplot). M√≠nimo 5
gr√°ficos, m√°ximo 8 (*)

Uso de color y texto (15 puntos): en cada gr√°fica o visualizaci√≥n componente, el uso de t√≠tulos,
etiquetas, textos descriptivos y colores, debe ser concordante con los objetivos descritos.

Organizaci√≥n y coherencia (10 puntos): las visualizaciones deben organizarse
significativamente en la pantalla, y ser coherentes o complementarias entre s√≠. El usuario debe
entender cada una de las visualizaciones y su orden de presentaci√≥n.

Presentaci√≥n y demostraci√≥n (20 puntos): el dise√±o y ejecuci√≥n del dashboard debe ser
presentado. Se evaluar√°n los aspectos anteriores en una exposici√≥n de no m√°s de 15 minutos,
m√°s las respuestas y participaci√≥n en un periodo de consultas y discusi√≥n de 10 minutos.

Escala de notas: http://bit.ly/3ypiNep (http://bit.ly/3ypiNep)

(*) Los gr√°ficos elegidos deben corresponder, cada uno, a una de las siguientes categor√≠as:

a) gr√°ficas de series de tiempo

b) gr√°ficas comparativas de dos variables en el tiempo

c) gr√°ficas de distribuci√≥n estad√≠stica

d) gr√°ficas de composici√≥n

e) gr√°ficas de correlaci√≥n

f) nube de palabras clave

g) mapas con marcadores o coropl√©ticos, de acuerdo al nivel de granularidad de los mapas

Entrega:

Los entregables consisten en:

C√≥digo fuente, con comentarios que contribuyan a su comprensi√≥n, an√°lisis y pruebas (ej:
indicaci√≥n de par√°metros modificables), en sistema gestor de versiones Github o similar
Demostraci√≥n de su ejecuci√≥n (deseable respaldarse con v√≠deo de ejecuci√≥n).
Algunos datasets que pueden utilizar (pueden usar propios)
COVID19 (minciencia.gob.cl)

Elegir datasets de acuerdo a objetivo consensuado por equipo :

(https://www.minciencia.gob.cl/covid19/)
SOWC-Statistical-tables-ALL-2021-ES.xlsx

(https://udec.instructure.com/courses/67338/files/3739117?wrap=1)
(https://udec.instructure.com/courses/67338/files/3739117/download?download_frd=1)
(M√∫ltiples datos de UNICEF, pueden repartirse entre grupos las distintas hojas del libro)

https://grouplens.org/datasets/movielens/ (https://grouplens.org/datasets/movielens/)
(Dataset de pel√≠culas y puntuaciones de usuarios)

Datasets de Kaggle (https://www.kaggle.com/datasets)

Datasets de PapersWithCode (https://paperswithcode.com/datasets)

datos : datos
Fecha

Condici√≥n (clima, luz)

Tipo de choque

Condici√≥n de la calle

Da√±o en $$
Causa del choque



Cliente:

municipalidad

Objetivo general

Analizar informaci√≥n de datos para poder realizar campa√±a de prevenci√≥n de accidentes de autos

Objetivos espec√≠ficos

Analizar la gravedad del siniestro

Revisar fechas para poder generar campa√±as

An√°lisis de condiciones: clim√°ticas, iluminaci√≥n, momento del d√≠a, calle

Tipo de accidente

Costo del accidente

Fuete de datos : https://www.kaggle.com/datasets/oktayrdeki/traffic-accidents

Exploracion de datos

PROYECTO PROPAGANDA DE PREVENCI√ìN DE ACCIDENTES
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from IPython.display import display, HTML
csv_datos= '/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/traffic_accidents.csv'
df_datos= pd.read_csv(csv_datos)
#df_datos= pd.read_csv(csv_datos, sep=';')
# T√≠tulo del DataFrame con formato
titulo = "<h2 style='font-size: 24px; font-weight: bold;'>LIMPIEZA DE DATOS</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo))

# Mostrar el DataFrame
display(df_datos.head(5))

titulo_desc = "<h2 style='font-size: 24px; font-weight: bold;'>DESCRIPCI√ìN DE LOS DATOS</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_desc))
df_datos.describe()

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>TIPO DE DATOS</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))
# datos
print(df_datos.dtypes)

import pandas as pd

# Mostrar los valores √∫nicos de la columna
traffic_control_device = df_datos['weather_condition'].unique()

# Mostrar los valores
print(traffic_control_device)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


# Graficar la frecuencia de los valores de la columna
plt.figure(figsize=(10, 6))

# Crear el gr√°fico de barras (conteo de categor√≠as)
sns.countplot(data=df_datos, x='weather_condition', palette='Set2')

# A√±adir t√≠tulos y etiquetas
plt.title('Frecuencia')#, fontsize=14)
plt.xlabel('Clima') , #fontsize=8)
plt.ylabel('Frecuencia') #, fontsize=12)

plt.xticks(fontsize=10, rotation=45)
plt.yticks(fontsize=10)

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 1: REVISAR LA CONDICI√ìN CLIM√ÅTICA QUE M√ÅS INCIDE EN EL ACCIDENTE</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))

# Mostrar el gr√°fico
plt.show()

"""

```
# Tiene formato de c√≥digo
```

#PARTE VICKY
  ![image.png](data:image/png;base64,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)"""

import matplotlib.pyplot as plt
import seaborn as sns

# Estilo de gr√°ficos
sns.set(style="whitegrid")

# Gr√°fico de distribuci√≥n por hora del d√≠a
plt.figure(figsize=(10, 6))
sns.histplot(df_datos['crash_hour'].dropna(), bins=24, kde=False)
plt.title('Distribuci√≥n de Accidentes por Hora del D√≠a')
plt.xlabel('Hora del D√≠a (0-23)')
plt.ylabel('Cantidad de Accidentes')
plt.xticks(range(0, 24))  # Marcar todas las horas

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 2: ANALIZAR EL HORARIO DEL ACCIDENTE</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


# Contar ocurrencias por condici√≥n clim√°tica
weather_counts = df_datos['lighting_condition'].value_counts()

# Agrupar categor√≠as menores bajo "OTROS"
threshold = 0.03  # Agrupar si es menos del 3% del total
total = weather_counts.sum()
weather_grouped = weather_counts[weather_counts / total >= threshold]
otros = weather_counts[weather_counts / total < threshold].sum()
weather_grouped["OTROS"] = otros

# Preparar datos
labels = weather_grouped.index
sizes = weather_grouped.values
explode = [0.05 if size / sum(sizes) < 0.1 else 0 for size in sizes]  # resaltar los m√°s peque√±os

# Crear gr√°fico de pastel
plt.figure(figsize=(12, 10))
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    startangle=140,
    explode=explode,
    pctdistance=0.8,
    labeldistance=1.1,
    textprops={'fontsize': 11},
    wedgeprops=dict(edgecolor='white'),
    radius=0.8
)

# A√±adir flechas a cada segmento, desde la orilla hacia las etiquetas
for i, wedge in enumerate(wedges):
    angle = (wedge.theta2 + wedge.theta1) / 2  # √Ångulo medio del segmento
    x = wedge.r * np.cos(np.radians(angle))  # Coordenada x en la orilla
    y = wedge.r * np.sin(np.radians(angle))  # Coordenada y en la orilla
    # Coordenadas donde apunta la flecha (hacia las etiquetas)
    label_x, label_y = texts[i].get_position()

    plt.annotate(
        '',
        xy=(label_x, label_y),  # Coordenada donde apunta la flecha (la etiqueta)
        xytext=(x, y),  # Coordenada desde donde sale la flecha (la orilla de la torta)
        arrowprops=dict(arrowstyle='->', lw=1.5, color='gray')  # Estilo de la flecha gris
    )


titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 3: ANALIZAR COMO INFLUYE LA LUZ DEL D√çA</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))

# T√≠tulo
plt.title('Composici√≥n de Accidentes por Condici√≥n Clim√°tica (Agrupado)', fontsize=14)

# Mostrar gr√°fico
plt.tight_layout()
plt.show()

"""first_crash_type_PEDESTRIAN ‚Üí correlaci√≥n: 0.15

üî∫ Cuando el primer impacto es con un peat√≥n, hay m√°s probabilidad de que haya personas lesionadas.

‚úîÔ∏è Tiene sentido, ya que los peatones son m√°s vulnerables.

damage_OVER $1,500 ‚Üí correlaci√≥n: 0.12

üî∫ Accidentes con alto da√±o econ√≥mico tienden a tener m√°s heridos.

Puede ser reflejo de accidentes m√°s violentos.

PARTE FABI
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Paso 1: unir todos los valores de la columna en un solo string
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))

# Paso 2: crear el WordCloud
wordcloud = WordCloud(width=800, height=400, background_color='white', collocations=False).generate(text)

# Paso 3: mostrar el WordCloud
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 4: COMPRENDER QUE HAC√çA EL VEHICULO CUANDO OCURRE EL CHOQUE</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))

plt.figure(figsize=(10, 5))
plt.title('Gr√°fico de palabras de Tipo de choque', fontsize=18)
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

"""Parte Gabriel

b) Gr√°ficas comparativas de dos variables en el tiempo

     - lineplot
     T√≠picamente, el eje-y representa un valor cuantitativo , mientras el x es una esacala de tiempos

     - area plot
     Puede ser usada para mostrar comparativamente la evolucion de variables en el tiempo

    -Similar a un Lineplot, es otra representaci√≥n de la evoluci√≥n de una variable num√©rica
    ‚Ä¢ El √°rea entre la l√≠nea trazada por la uni√≥n de los data points y el eje-x es llenada con color o sombra
    ‚Ä¢ Se discute su alta relaci√≥n Tinta/Dato
    ‚Ä¢ Puede ser dif√≠cil de visualizar cantidades en √°reas apiladas
    ‚Ä¢ Puede ser dif√≠cil distinguirvarias variables en √°reas no apiladas

    BAR CHARTS                                                                  ‚Ä¢ Compara datos cuantitativos de diferentes √≠tems o categor√≠as           -   Describe cambios en el tiempo, para periodo significativos y discretos



"""

import pandas as pd


# Crear un nuevo DataFrame df_datos_II que solo contenga tres columnas especificadas
df_datos_II = df_datos[['crash_date', 'injuries_incapacitating', 'injuries_non_incapacitating','crash_month']]

# Mostrar las primeras filas
print(df_datos_II.head())

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Crear un nuevo DataFrame df_datos_II que solo contenga las tres columnas especificadas
df_datos_III = df_datos[['crash_month', 'injuries_incapacitating', 'injuries_non_incapacitating']]

# Agrupar por 'crash_month' y contar la cantidad de accidentes incapacitating y no incapacitating
df_injuries = df_datos_III.groupby(['crash_month'])[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()

# Graficar en un gr√°fico de √°rea comparativa
df_injuries.plot(kind='area',
                 alpha=0.5,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                 stacked=False,
                 figsize=(12, 6),
                 color=['red', 'blue'])  # Cambiar colores: rojo para incapacitantes y azul para no incapacitantes)

plt.title('Comparativa de Accidentes Incapacitantes y No Incapacitantes agrupados por meses (2013 -2024)')
plt.ylabel('N√∫mero de Accidentes')
plt.xlabel('Meses')
plt.xticks(rotation=45)  # Para rotar las etiquetas de fecha
plt.tight_layout()  # Ajustar el dise√±o para que no se solapen los elementos
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 5: ANALIZAR SI EXISTE UNA VARIACI√ìN SEG√öN EL MES DEL A√ëO, DE ACCIDENTE INCAPACITANTES Y NO INCAPACITANTES</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))

plt.show()

"""e) Gr√°ficas de correlaci√≥n

SCATTER PLOT ‚Ä¢ Despliega valores de dos variables, una en cada eje cartesiano.

‚Ä¢ Permite detectar si existe una relaci√≥n o correlaci√≥n entre ambas variables.

SCATTER PLOT: TIPOS DE CORRELACI√ìN

‚Ä¢ Positiva: x e y aumentan juntos

‚Ä¢ Negativa: uno aumenta y el otro disminuye

‚Ä¢ Nula: no hay correlaci√≥n

‚Ä¢ Lineal

‚Ä¢ Exponencial

‚Ä¢ Forma de U

SCATTER PLOT: FORTALEZA DE CORRELACI√ìN

‚Ä¢ La fortaleza de la correlaci√≥n se determina por la cercan√≠a entre los puntos en el gr√°fico.

‚Ä¢ Puntos muy fuera de los cluster de puntos son outliers.

SCATTER PLOT: DESCRIPCI√ìN

Los markers representan la correspondencia entre dos valores de correspondientes variables descritas en los ejes x e Y.

‚Ä¢ Se muestra una l√≠nea que representa la funci√≥n de regresi√≥n lineal m√°s descriptiva de la correspondencia entre las variables ‚Ä¢ Opcionalmente, se muestra el intervalo de confianza asociado

¬ø Bubble Chart ?
"""

# SCATTER PLOT : graficos de correlacion
# instalaci√≥n de seaborn
!conda install -c anaconda seaborn --yes

# importamos biblioteca
import seaborn as sns

print('Seaborn installed and imported!')

#crea un nuevo df

# Extraer solo el a√±o para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year

# Agrupar por a√±o y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los a√±os a float
df_totals.index = map(float, df_totals.index)

# Resetear el √≠ndice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Mostrar el DataFrame resultante
print(df_datos_scatter.head())

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


# Extraer solo el a√±o para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year



# Agrupar por 'year' y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los a√±os a float (√∫til para posterior regresi√≥n)
df_totals.index = map(float, df_totals.index)

# Resetear el √≠ndice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Crear un scatter plot con seaborn
sns.set_style("dark")
ax = sns.regplot(x='year', y='total_accidents', data=df_datos_scatter, marker="o")

plt.title(' Accidentes Totales por A√±o')
plt.xlabel('A√±o')
plt.ylabel('Accidentes Totales')
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 6: ANALIZAR SI EXISTE UNA VARIACI√ìN EN EL TIEMPO DEL TOTAL DE ACCIDENTES</h2>"

# Mostrar el t√≠tulo
display(HTML(titulo_type))

plt.show()

"""Bubble Charts

"""

import pandas as pd


# Extraer solo el a√±o para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year


# Agrupar por a√±o y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los a√±os a float
df_totals.index = map(float, df_totals.index)

# Resetear el √≠ndice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Agrupar por a√±o y sumar el n√∫mero total de unidades
df_units = pd.DataFrame(df_datos.groupby('year')['num_units'].sum())

# Resetear el √≠ndice para regresarlo como columna en el DataFrame df_units
df_units.reset_index(inplace=True)

# Renombrar columnas
df_units.columns = ['year', 'total_units']

# Combinar los DataFrames df_totals y df_units
df_datos_b = pd.merge(df_totals, df_units, on='year')

# Mostrar el DataFrame resultante
print(df_datos_b.head(11))

"""Animaci√≥n del bubblechart  en el tiempo, considerando todos los a√±os del dataset

Instalando librerias
"""

# instalamos plotly
!conda install -c anaconda plotly --yes
# instalamos plotly express, para resultados con mayor interactividad
!conda install -c plotly plotly_express --yes
# instalamos plotly express, para resultados con mayor interactividad
!conda install -c plotly plotly_express --yes
# instalamos plotly
!pip install plotly

!pip install plotly
import plotly.express as px

!pip install dash
!pip install pyngrok
!pip install dash dash-bootstrap-components plotly pandas wordcloud
!pip install dash dash-bootstrap-components pyngrok wordcloud

import dash
from dash import dcc, html, Input, Output
import plotly.express as px
import pandas as pd
from wordcloud import WordCloud
from io import BytesIO
import base64
from pyngrok import ngrok
import threading

# ‚úÖ Simulaci√≥n del DataFrame (puedes reemplazar por el tuyo)
# df_datos = pd.read_csv("tu_archivo.csv")
df_datos = pd.DataFrame({
    'weather_condition': ['Clear', 'Rain', 'Snow'] * 100,
    'crash_hour': [i % 24 for i in range(300)],
    'lighting_condition': ['Daylight', 'Darkness', 'Dawn'] * 100,
    'first_crash_type': ['Turning', 'Rear-end', 'Sideswipe'] * 100,
    'crash_month': ['Enero', 'Febrero', 'Marzo'] * 100,
    'injuries_incapacitating': [i % 5 for i in range(300)],
    'injuries_non_incapacitating': [i % 7 for i in range(300)],
    'crash_date': ['01/01/2023 01:00:00 AM'] * 300,
    'injuries_total': [i % 10 for i in range(300)]
})

# Preparar datos para gr√°ficos
df_datos['crash_date'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p")
df_datos['year'] = df_datos['crash_date'].dt.year

# Crear WordCloud
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))
wordcloud = WordCloud(width=800, height=400, background_color='white').generate(text)
img = BytesIO()
wordcloud.to_image().save(img, format='PNG')
img_base64 = base64.b64encode(img.getvalue()).decode()

# Crear la app
app = dash.Dash(__name__)
server = app.server

app.layout = html.Div([
    html.H1("Dashboard de Accidentes de Tr√°fico", style={'textAlign': 'center'}),

    html.Div([
        html.Div([
            html.H3("OBJETIVO 1: Condici√≥n clim√°tica m√°s incidente"),
            dcc.Graph(
                figure=px.histogram(df_datos, x='weather_condition')
            )
        ], className='six columns'),

        html.Div([
            html.H3("OBJETIVO 2: An√°lisis de horario"),
            dcc.Graph(
                figure=px.histogram(df_datos, x='crash_hour', nbins=24)
            )
        ], className='six columns'),
    ], className='row'),

    html.Div([
        html.Div([
            html.H3("OBJETIVO 3: Iluminaci√≥n al momento del accidente"),
            dcc.Graph(
                figure=px.pie(
                    names=(df_datos['lighting_condition'].value_counts().index),
                    values=(df_datos['lighting_condition'].value_counts().values)
                )
            )
        ], className='six columns'),

        html.Div([
            html.H3("OBJETIVO 4: WordCloud del tipo de choque"),
            html.Img(src=f'data:image/png;base64,{img_base64}', style={"width": "100%"})
        ], className='six columns'),
    ], className='row'),

    html.Div([
        html.H3("OBJETIVO 5: Accidentes mensuales"),
        dcc.Graph(
            figure=px.area(
                df_datos.groupby('crash_month')[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()
            )
        )
    ]),

    html.Div([
        html.H3("OBJETIVO 6: Evoluci√≥n anual de accidentes"),
        dcc.Graph(
            figure=px.scatter(
                df_datos.groupby('year')['injuries_total'].sum().reset_index(),
                x='year', y='injuries_total', trendline='ols'
            )
        )
    ])
])

def run_dash():
    app.run(port=8050)

# Crear t√∫nel ngrok
public_url = ngrok.connect(8050)
print("Tu dashboard interactivo est√° en:", public_url)

# Iniciar el servidor Dash en segundo plano
thread = threading.Thread(target=run_dash)
thread.start()

'''import pandas as pd
import plotly.express as px
from wordcloud import WordCloud
from io import BytesIO
import base64

# Aseg√∫rate de tener cargado df_datos

# Gr√°fico 1
fig1 = px.histogram(df_datos, x='weather_condition')
fig1.update_layout(title=None)
html1 = fig1.to_html(full_html=False, include_plotlyjs='cdn', config={'displayModeBar': False})

# Gr√°fico 2
fig2 = px.histogram(df_datos, x='crash_hour', nbins=24)
fig2.update_layout(title=None)
html2 = fig2.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# Gr√°fico 3
lighting = df_datos['lighting_condition'].value_counts()
grouped = lighting[lighting / lighting.sum() >= 0.03]
grouped['OTROS'] = lighting[lighting / lighting.sum() < 0.03].sum()
fig3 = px.pie(names=grouped.index, values=grouped.values)
fig3.update_layout(title=None)
html3 = fig3.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# WordCloud (Gr√°fico 4)
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))
wordcloud = WordCloud(width=800, height=400, background_color='white').generate(text)
img = BytesIO()
wordcloud.to_image().save(img, format='PNG')
img_base64 = base64.b64encode(img.getvalue()).decode()

# Gr√°fico 5
df_datos_mes = df_datos.groupby('crash_month')[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()
fig5 = px.area(df_datos_mes)
fig5.update_layout(title=None)
html5 = fig5.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# Gr√°fico 6
df_datos['year'] = pd.to_datetime(df_datos['crash_date'], format="%m/%d/%Y %I:%M:%S %p").dt.year
df_datos_anual = df_datos.groupby('year')['injuries_total'].sum().reset_index()
fig6 = px.scatter(df_datos_anual, x='year', y='injuries_total', trendline="ols")
fig6.update_layout(title=None)
html6 = fig6.to_html(full_html=False, include_plotlyjs=False, config={'displayModeBar': False})

# HTML final con layout 2, 2, 1, 1
html_dashboard = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dashboard de Accidentes</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {{
            font-family: 'Segoe UI', sans-serif;
            background-color: #f4f6f8;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1200px;
            margin: auto;
        }}
        h1 {{
            text-align: center;
            color: #333;
            margin-bottom: 40px;
        }}
        .grid {{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }}
        .card {{
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            padding: 20px;
        }}
        .card h2 {{
            font-size: 18px;
            color: #007BFF;
            margin-bottom: 10px;
        }}
        .full-width {{
            grid-column: span 2;
        }}
        img {{
            width: 100%;
            max-width: 800px;
            display: block;
            margin: auto;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
        }}
        @media (max-width: 768px) {{
            .grid {{
                grid-template-columns: 1fr;
            }}
            .full-width {{
                grid-column: span 1;
            }}
        }}
    </style>
</head>
<body>

<div class="container">
    <h1>Dashboard de Accidentes de Tr√°fico</h1>

    <div class="grid">
        <div class="card">
            <h2>OBJETIVO 1: REVISAR LA CONDICI√ìN CLIM√ÅTICA QUE M√ÅS INCIDE EN EL ACCIDENTE</h2>
            {html1}
        </div>
        <div class="card">
            <h2>OBJETIVO 2: ANALIZAR EL HORARIO DEL ACCIDENTE</h2>
            {html2}
        </div>

        <div class="card">
            <h2>OBJETIVO 3: ANALIZAR C√ìMO INFLUYE LA LUZ DEL D√çA</h2>
            {html3}
        </div>
        <div class="card">
            <h2>OBJETIVO 4: COMPRENDER QU√â HAC√çA EL VEH√çCULO CUANDO OCURRE EL CHOQUE</h2>
            <img src="data:image/png;base64,{img_base64}" alt="WordCloud del tipo de choque">
        </div>

        <div class="card full-width">
            <h2>OBJETIVO 5: ANALIZAR LA VARIACI√ìN MENSUAL DE ACCIDENTES INCAPACITANTES Y NO INCAPACITANTES</h2>
            {html5}
        </div>
        <div class="card full-width">
            <h2>OBJETIVO 6: ANALIZAR LA EVOLUCI√ìN EN EL TIEMPO DEL TOTAL DE ACCIDENTES</h2>
            {html6}
        </div>
    </div>
</div>

</body>
</html>
"""

# Guardar archivo
with open("dashboard_accidentes.html", "w", encoding="utf-8") as f:
    f.write(html_dashboard)

# Descargar desde Colab
from google.colab import files
files.download("dashboard_accidentes.html")