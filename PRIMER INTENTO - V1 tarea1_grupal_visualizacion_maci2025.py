# -*- coding: utf-8 -*-
"""tarea1_grupal_visualizacion_maci2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZ6LIfcW6SLxAP506pkP-DQU6Q9BzSJd

# Proyecto Dashboard


  El proyecto consiste en desarrollar un Dashboard, que integre un conjunto de visualizaciones
significativo en el dominio o ámbito de un dataset a elegir. El proyecto será desarrollado en equipos
de 3 integrantes.

Los aspectos a evaluar serán los siguientes:

Objetivo de la visualización (15 puntos): debe estar explícitamente incluido en la visualización.

Todos los componentes de la visualización deberán contribuir a dicho objetivo, lo que puede ser
reforzado con texto explicativo. El objetivo incluirá una descripción de potenciales usuarios y
contexto de uso.

Pertinencia y corrección del Dashboard (40 puntos): el Dashboard y sus componentes, junto
con estar correctamente implementados, deberán responder al objetivo específico que se
anuncia (ej: a continuación, mostramos la evolución en el tiempo de esta variable => lineplot, o
vemos cómo se corresponde esta variable con esta otra => scatter o bubbleplot). Mínimo 5
gráficos, máximo 8 (*)

Uso de color y texto (15 puntos): en cada gráfica o visualización componente, el uso de títulos,
etiquetas, textos descriptivos y colores, debe ser concordante con los objetivos descritos.

Organización y coherencia (10 puntos): las visualizaciones deben organizarse
significativamente en la pantalla, y ser coherentes o complementarias entre sí. El usuario debe
entender cada una de las visualizaciones y su orden de presentación.

Presentación y demostración (20 puntos): el diseño y ejecución del dashboard debe ser
presentado. Se evaluarán los aspectos anteriores en una exposición de no más de 15 minutos,
más las respuestas y participación en un periodo de consultas y discusión de 10 minutos.

Escala de notas: http://bit.ly/3ypiNep (http://bit.ly/3ypiNep)

(*) Los gráficos elegidos deben corresponder, cada uno, a una de las siguientes categorías:

a) gráficas de series de tiempo

b) gráficas comparativas de dos variables en el tiempo

c) gráficas de distribución estadística

d) gráficas de composición

e) gráficas de correlación

f) nube de palabras clave

g) mapas con marcadores o coropléticos, de acuerdo al nivel de granularidad de los mapas

Entrega:

Los entregables consisten en:

Código fuente, con comentarios que contribuyan a su comprensión, análisis y pruebas (ej:
indicación de parámetros modificables), en sistema gestor de versiones Github o similar
Demostración de su ejecución (deseable respaldarse con vídeo de ejecución).
Algunos datasets que pueden utilizar (pueden usar propios)
COVID19 (minciencia.gob.cl)

Elegir datasets de acuerdo a objetivo consensuado por equipo :

(https://www.minciencia.gob.cl/covid19/)
SOWC-Statistical-tables-ALL-2021-ES.xlsx

(https://udec.instructure.com/courses/67338/files/3739117?wrap=1)
(https://udec.instructure.com/courses/67338/files/3739117/download?download_frd=1)
(Múltiples datos de UNICEF, pueden repartirse entre grupos las distintas hojas del libro)

https://grouplens.org/datasets/movielens/ (https://grouplens.org/datasets/movielens/)
(Dataset de películas y puntuaciones de usuarios)

Datasets de Kaggle (https://www.kaggle.com/datasets)

Datasets de PapersWithCode (https://paperswithcode.com/datasets)

datos : datos
Fecha

Condición (clima, luz)

Tipo de choque

Condición de la calle

Daño en $$
Causa del choque



Cliente:

municipalidad

Objetivo general

Analizar información de datos para poder realizar campaña de prevención de accidentes de autos

Objetivos específicos

Analizar la gravedad del siniestro

Revisar fechas para poder generar campañas

Análisis de condiciones: climáticas, iluminación, momento del día, calle

Tipo de accidente

Costo del accidente

Fuete de datos : https://www.kaggle.com/datasets/oktayrdeki/traffic-accidents

Exploracion de datos

PROYECTO PROPAGANDA DE PREVENCIÓN DE ACCIDENTES
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from IPython.display import display, HTML
csv_datos= '/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/traffic_accidents.csv'
df_datos= pd.read_csv(csv_datos)
#df_datos= pd.read_csv(csv_datos, sep=';')
# Título del DataFrame con formato
titulo = "<h2 style='font-size: 24px; font-weight: bold;'>LIMPIEZA DE DATOS</h2>"

# Mostrar el título
display(HTML(titulo))

# Mostrar el DataFrame
display(df_datos.head(5))

titulo_desc = "<h2 style='font-size: 24px; font-weight: bold;'>DESCRIPCIÓN DE LOS DATOS</h2>"

# Mostrar el título
display(HTML(titulo_desc))
df_datos.describe()

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>TIPO DE DATOS</h2>"

# Mostrar el título
display(HTML(titulo_type))
# datos
print(df_datos.dtypes)

import pandas as pd

# Mostrar los valores únicos de la columna
traffic_control_device = df_datos['weather_condition'].unique()

# Mostrar los valores
print(traffic_control_device)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


# Graficar la frecuencia de los valores de la columna
plt.figure(figsize=(10, 6))

# Crear el gráfico de barras (conteo de categorías)
sns.countplot(data=df_datos, x='weather_condition', palette='Set2')

# Añadir títulos y etiquetas
plt.title('Frecuencia')#, fontsize=14)
plt.xlabel('Clima') , #fontsize=8)
plt.ylabel('Frecuencia') #, fontsize=12)

plt.xticks(fontsize=10, rotation=45)
plt.yticks(fontsize=10)

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 1: REVISAR LA CONDICIÓN CLIMÁTICA QUE MÁS INCIDE EN EL ACCIDENTE</h2>"

# Mostrar el título
display(HTML(titulo_type))

# Mostrar el gráfico
plt.show()

"""

```
# Tiene formato de código
```

#PARTE VICKY
  ![image.png](data:image/png;base64,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)"""

import matplotlib.pyplot as plt
import seaborn as sns

# Estilo de gráficos
sns.set(style="whitegrid")

# Gráfico de distribución por hora del día
plt.figure(figsize=(10, 6))
sns.histplot(df_datos['crash_hour'].dropna(), bins=24, kde=False)
plt.title('Distribución de Accidentes por Hora del Día')
plt.xlabel('Hora del Día (0-23)')
plt.ylabel('Cantidad de Accidentes')
plt.xticks(range(0, 24))  # Marcar todas las horas

titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 2: ANALIZAR EL HORARIO DEL ACCIDENTE</h2>"

# Mostrar el título
display(HTML(titulo_type))
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Contar ocurrencias por condición climática
weather_counts = df_datos['lighting_condition'].value_counts()

# Agrupar categorías menores bajo "OTROS"
threshold = 0.03  # Agrupar si es menos del 3% del total
total = weather_counts.sum()
weather_grouped = weather_counts[weather_counts / total >= threshold]
otros = weather_counts[weather_counts / total < threshold].sum()
weather_grouped["OTROS"] = otros

# Preparar datos
labels = weather_grouped.index
sizes = weather_grouped.values
explode = [0.05 if size / sum(sizes) < 0.1 else 0 for size in sizes]  # resaltar los más pequeños

# Crear gráfico de pastel
plt.figure(figsize=(12, 10))
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    startangle=140,
    explode=explode,
    pctdistance=0.8,
    labeldistance=1.1,
    textprops={'fontsize': 11},
    wedgeprops=dict(edgecolor='white'),
    radius=0.8
)

# Añadir flechas a cada segmento, desde la orilla hacia las etiquetas
for i, wedge in enumerate(wedges):
    angle = (wedge.theta2 + wedge.theta1) / 2  # Ángulo medio del segmento
    x = wedge.r * np.cos(np.radians(angle))  # Coordenada x en la orilla
    y = wedge.r * np.sin(np.radians(angle))  # Coordenada y en la orilla
    # Coordenadas donde apunta la flecha (hacia las etiquetas)
    label_x, label_y = texts[i].get_position()

    plt.annotate(
        '',
        xy=(label_x, label_y),  # Coordenada donde apunta la flecha (la etiqueta)
        xytext=(x, y),  # Coordenada desde donde sale la flecha (la orilla de la torta)
        arrowprops=dict(arrowstyle='->', lw=1.5, color='gray')  # Estilo de la flecha gris
    )


titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 3: ANALIZAR COMO INFLUYE LA LUZ DEL DÍA</h2>"

# Mostrar el título
display(HTML(titulo_type))

# Título
plt.title('Composición de Accidentes por Condición Climática (Agrupado)', fontsize=14)

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Selección de variables categóricas relevantes
categorical_vars = [
    'weather_condition',
    'lighting_condition',
    'roadway_surface_cond',
    'traffic_control_device',
    'first_crash_type',
    'trafficway_type',
    'alignment',
    'damage'
]

# Aplicar one-hot encoding
df_encoded = pd.get_dummies(df_datos[categorical_vars], drop_first=True)

# Agregar la variable 'injuries_total' al nuevo DataFrame
df_encoded['injuries_total'] = df_datos['injuries_total']

# Calcular la matriz de correlación y seleccionar las 15 más relacionadas con 'injuries_total'
correlations = df_encoded.corr()['injuries_total'].drop('injuries_total').sort_values(ascending=False)
top_correlated = correlations.head(15).index.tolist()


titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 4: ENCONTRAR LA CORRELACIÓN DE LA INFORMACIÓN (VARIABLES)</h2>"

# Mostrar el título
display(HTML(titulo_type))

# Crear el mapa de calor
plt.figure(figsize=(14, 12))
sns.heatmap(df_encoded[top_correlated + ['injuries_total']].corr(), annot=True, cmap='coolwarm', fmt=".2f",annot_kws={'size': 9}, cbar_kws={'shrink': 0.8})

plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(rotation=0, fontsize=10)
plt.title('Mapa de Calor: Variables Categóricas vs Lesiones Totales')
plt.tight_layout()
plt.show()

"""first_crash_type_PEDESTRIAN → correlación: 0.15

🔺 Cuando el primer impacto es con un peatón, hay más probabilidad de que haya personas lesionadas.

✔️ Tiene sentido, ya que los peatones son más vulnerables.

damage_OVER $1,500 → correlación: 0.12

🔺 Accidentes con alto daño económico tienden a tener más heridos.

Puede ser reflejo de accidentes más violentos.

PARTE FABI
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Paso 1: unir todos los valores de la columna en un solo string
text = ' '.join(df_datos['first_crash_type'].dropna().astype(str))

# Paso 2: crear el WordCloud
wordcloud = WordCloud(width=800, height=400, background_color='white', collocations=False).generate(text)

# Paso 3: mostrar el WordCloud
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 5: COMPRENDER QUE HACÍA EL VEHICULO CUANDO OCURRE EL CHOQUE</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.figure(figsize=(10, 5))
plt.title('Gráfico de palabras de Tipo de choque', fontsize=18)
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

"""Parte Gabriel

b) Gráficas comparativas de dos variables en el tiempo

     - lineplot
     Típicamente, el eje-y representa un valor cuantitativo , mientras el x es una esacala de tiempos

     - area plot
     Puede ser usada para mostrar comparativamente la evolucion de variables en el tiempo

    -Similar a un Lineplot, es otra representación de la evolución de una variable numérica
    • El área entre la línea trazada por la unión de los data points y el eje-x es llenada con color o sombra
    • Se discute su alta relación Tinta/Dato
    • Puede ser difícil de visualizar cantidades en áreas apiladas
    • Puede ser difícil distinguirvarias variables en áreas no apiladas

    BAR CHARTS                                                                  • Compara datos cuantitativos de diferentes ítems o categorías           -   Describe cambios en el tiempo, para periodo significativos y discretos



"""

print('data dimensions:', df_datos.shape)
print(df_datos.columns)
df_datos.head(2)

import pandas as pd


# Crear un nuevo DataFrame df_datos_II que solo contenga tres columnas especificadas
df_datos_II = df_datos[['crash_date', 'injuries_incapacitating', 'injuries_non_incapacitating','crash_month']]

# Mostrar las primeras filas
print(df_datos_II.head())

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

"""

# Asegurarnos de que 'crash_date' es tipo datetime
df_datos_II['crash_date'] = pd.to_datetime(df_datos_II['crash_date'])

# Extraer solo la fecha y la hora para usar en el eje X
df_datos_II['date_hour'] = df_datos_II['crash_date'].dt.floor('H')  # Esto nos da año-mes-día hora (por ejemplo 2020-01-01 00:00:00)

# Agrupar por 'date_hour' y contar la cantidad de accidentes incapacitating y no incapacitating
df_injuries = df_datos_II.groupby(['date_hour'])[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()

# Graficar en un gráfico de área comparativa
df_injuries.plot(kind='area',
                 alpha=0.3,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                 stacked=False,
                 figsize=(20, 8),
                 color=['red', 'blue'])

plt.title('Comparativa de Accidentes Incapacitantes y No Incapacitantes')
plt.ylabel('Número de Accidentes')
plt.xlabel('Fecha y Hora')
plt.xticks(rotation=45)  # Para rotar las etiquetas de fecha
plt.tight_layout()  # Ajustar el diseño para que no se solapen los elementos
plt.show()

"""import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Supongamos que tienes el DataFrame df_datos_II
# Asegurarnos de que 'crash_date' es tipo datetime
df_datos_II['crash_date'] = pd.to_datetime(df_datos_II['crash_date'])

# Extraer solo el año para usar en el eje X
df_datos_II['year'] = df_datos_II['crash_date'].dt.year

# Agrupar por 'year' y contar la cantidad de accidentes incapacitantes y no incapacitantes
df_injuries = df_datos_II.groupby(['year'])[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()

# Graficar en un gráfico de área comparativa con colores específicos
df_injuries.plot(kind='area',
                 alpha=0.6,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                 stacked=False,
                 figsize=(15, 6),
                 color=['red', 'blue'])  # Cambiar colores: rojo para incapacitantes y azul para no incapacitantes

plt.title('Comparativa de Accidentes Incapacitantes y No Incapacitantes por Año')
plt.ylabel('Número de Accidentes')
plt.xlabel('Años')
plt.xticks(np.arange(min(df_injuries.index), max(df_injuries.index)+1, 1))  # Asegurarnos de que los años sean correctos
plt.tight_layout()  # Ajustar el diseño para que no se solapen los elementos



plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Crear un nuevo DataFrame df_datos_II que solo contenga las tres columnas especificadas
df_datos_III = df_datos[['crash_month', 'injuries_incapacitating', 'injuries_non_incapacitating']]

# Agrupar por 'crash_month' y contar la cantidad de accidentes incapacitating y no incapacitating
df_injuries = df_datos_III.groupby(['crash_month'])[['injuries_incapacitating', 'injuries_non_incapacitating']].sum()

# Graficar en un gráfico de área comparativa
df_injuries.plot(kind='area',
                 alpha=0.5,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                 stacked=False,
                 figsize=(12, 6),
                 color=['red', 'blue'])  # Cambiar colores: rojo para incapacitantes y azul para no incapacitantes)

plt.title('Comparativa de Accidentes Incapacitantes y No Incapacitantes agrupados por meses (2013 -2024)')
plt.ylabel('Número de Accidentes')
plt.xlabel('Meses')
plt.xticks(rotation=45)  # Para rotar las etiquetas de fecha
plt.tight_layout()  # Ajustar el diseño para que no se solapen los elementos
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 5: ANALIZAR SI EXISTE UNA VARIACIÓN SEGÚN EL MES DEL AÑO, DE ACCIDENTE INCAPACITANTES Y NO INCAPACITANTES</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.show()

"""import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Crear un nuevo DataFrame df_datos_IV que contenga las columnas especificadas
df_datos_IV = df_datos[['crash_hour', 'crash_day_of_week', 'injuries_fatal', 'injuries_reported_not_evident', 'crash_date']]

# Asegurarnos de que 'crash_date' es tipo datetime
df_datos_IV['crash_date'] = pd.to_datetime(df_datos_IV['crash_date'])

# Extraer solo el año para usar en el eje X
df_datos_IV['year'] = df_datos_IV['crash_date'].dt.year

# Agrupar por 'year' y contar la cantidad de accidentes fatales y reportados no evidentes
df_injuries_comparison = df_datos_IV.groupby(['year'])[['injuries_fatal', 'injuries_reported_not_evident']].sum()

# Graficar en un gráfico de área comparativa
df_injuries_comparison.plot(kind='area',
                            alpha=0.5,  # variamos el valor de transparencia (0-1, por defecto 0.5)
                            stacked=False,
                            figsize=(20, 8),
                            color=['red', 'blue'])

plt.title('Comparativa de Accidentes Fatales y Reportados No Evidentes por Año')
plt.ylabel('Número de Accidentes')
plt.xlabel('Años')
plt.xticks(np.arange(min(df_injuries_comparison.index), max(df_injuries_comparison.index)+1, 1))  # Asegurarnos de que los años sean correctos
plt.tight_layout()  # Ajustar el diseño para que no se solapen los elementos
plt.show()

"""e) Gráficas de correlación

SCATTER PLOT • Despliega valores de dos variables, una en cada eje cartesiano.

• Permite detectar si existe una relación o correlación entre ambas variables.

SCATTER PLOT: TIPOS DE CORRELACIÓN

• Positiva: x e y aumentan juntos

• Negativa: uno aumenta y el otro disminuye

• Nula: no hay correlación

• Lineal

• Exponencial

• Forma de U

SCATTER PLOT: FORTALEZA DE CORRELACIÓN

• La fortaleza de la correlación se determina por la cercanía entre los puntos en el gráfico.

• Puntos muy fuera de los cluster de puntos son outliers.

SCATTER PLOT: DESCRIPCIÓN

Los markers representan la correspondencia entre dos valores de correspondientes variables descritas en los ejes x e Y.

• Se muestra una línea que representa la función de regresión lineal más descriptiva de la correspondencia entre las variables • Opcionalmente, se muestra el intervalo de confianza asociado

¿ Bubble Chart ?
"""



# SCATTER PLOT : graficos de correlacion
# instalación de seaborn
!conda install -c anaconda seaborn --yes

# importamos biblioteca
import seaborn as sns

print('Seaborn installed and imported!')

#crea un nuevo df

# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date']).dt.year

# Agrupar por año y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Mostrar el DataFrame resultante
print(df_datos_scatter.head())

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Supongamos que tienes el DataFrame df_datos
# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date']).dt.year

# Agrupar por 'year' y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float (útil para posterior regresión)
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Crear un scatter plot con seaborn
sns.set_style("dark")
ax = sns.regplot(x='year', y='total_accidents', data=df_datos_scatter, marker="o")

plt.title(' Accidentes Totales por Año')
plt.xlabel('Año')
plt.ylabel('Accidentes Totales')
titulo_type = "<h2 style='font-size: 24px; font-weight: bold;'>OBJETIVO 6: ANALIZAR SI EXISTE UNA VARIACIÓN EN EL TIEMPO DEL TOTAL DE ACCIDENTES</h2>"

# Mostrar el título
display(HTML(titulo_type))

plt.show()

"""import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Supongamos que tienes el DataFrame df_datos
# Extraer solo el año para usar en el eje X
df_datos['year'] = pd.to_datetime(df_datos['crash_date']).dt.year

# Agrupar por 'year' y sumar la cantidad de accidentes totales
df_totals = pd.DataFrame(df_datos.groupby('year')['injuries_total'].sum())

# Cambiar los años a float (útil para posterior regresión)
df_totals.index = map(float, df_totals.index)

# Resetear el índice para regresarlo como columna en el DataFrame df_totals
df_totals.reset_index(inplace=True)

# Renombrar columnas
df_totals.columns = ['year', 'total_accidents']

# Crear el nuevo DataFrame df_datos_scatter
df_datos_scatter = df_totals

# Definir tamaño de la figura
plt.figure(figsize=(15, 10))

# Definir tamaño de fuente y estilo de fondo del scatterplot
sns.set(font_scale=1.5)
sns.set_style('whitegrid')

# Generar el scatterplot, añadiendo título y etiquetas de ejes
ax = sns.regplot(x='year', y='total_accidents', data=df_datos_scatter, color='red', marker='+', scatter_kws={'s': 200})
ax.set(xlabel='Year', ylabel='Total Accidents')
ax.set_title('Total Accidents by Year(2013-2018)')
plt.show()

"""import nbformat

# Ruta del archivo .ipynb
notebook_path = "/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/tarea1_grupal_visualizacion_maci2025.ipynb"
output_path = "/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/tarea1_grupal_visualizacion_maci2025_clean.ipynb"

# Cargar el archivo .ipynb
with open(notebook_path, 'r') as file:
    notebook = nbformat.read(file, as_version=4)

# Filtrar las celdas de salida (gráficos y resultados) sin texto ni código
clean_cells = []
for cell in notebook.cells:
    # Mantener solo las celdas de tipo 'code' que tengan salidas (gráficos)
    if cell.cell_type == 'code' and cell.outputs:
        clean_cells.append(cell)

# Crear un nuevo notebook solo con las celdas que contienen los gráficos
notebook.cells = clean_cells

# Guardar el nuevo archivo .ipynb limpio
with open(output_path, 'w') as file:
    nbformat.write(notebook, file)

# Convertir el notebook limpio a HTML
!jupyter nbconvert --to html --no-input --no-prompt --output "/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/tarea1_grupal_visualizacion_maci2025_clean.html" "$output_path"

# Moverlo a /content para poder descargarlo
!cp "/content/drive/MyDrive/MACI_TrimestreI_2025/Visualizacion_datos_MACI_2025/Tarea1_vizualizacion_grupos_Maci2025/tarea1_grupal_visualizacion_maci2025_clean.html" /content/

# Descargar el archivo HTML limpio
from google.colab import files
files.download("tarea1_grupal_visualizacion_maci2025_clean.html")
